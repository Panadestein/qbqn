# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: A quantum interpreter in BQN
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>

** Preamble

We start by importing the required system functions and defining a modifier to
work with complex matrix products. Then we create a namespace with some quantum gates:

#+name: preamble
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  Sin‿Cos‿GCD ← •math
  U ← •rand.Range
  _cp ← {(-´𝔽¨)⋈(+´𝔽¨)⟜⌽}
    
  g ← {
    IM ← (⊢⋈≢⥊⟜0⊢)¨
    id‿x‿h ⇐ (⌽‿⊢{𝕎𝕩}¨<=⌜˜↕2) ∾○IM <-⌾(1‿1⊸⊑)2‿2⥊÷√2
    swap‿cnot ⇐ IM ⟨1‿2, 2‿3⟩ {⌽⌾(𝕨⊸⊏)𝕩}¨ <=⌜˜↕4
    P ⇐ 3‿3⊸⊑{(Sin⌾𝔽⋈Cos⌾𝔽) 𝕩⌾𝔽 =⌜˜↕4}
  }
#+end_src

** Interpreter

The (call_count-chars() chars) quantum interpreter is based on references [[https://arxiv.org/abs/1711.02086][arXiv:1711.02086]]
and [[https://arxiv.org/abs/1608.03355][arXiv:1608.03355]]. For simplicity, we always measure at the end of the execution:

#+name: interpreter
#+begin_src bqn :exports code :tangle ./perf/q.bqn
  Q ← {𝕊qb‿sc:
    psi ← {(1⌾⊑⋈⊢)𝕩⥊0} 2⋆qb
    M‿K‿D ← ⟨+˝∘×⎉1‿∞ _cp, (∾⊣×·<⊢)_cp, {1+⌊2⋆⁼≠⊑𝕩}⟩
    L ← {E ← {0=𝕨 ? 1; K⍟(𝕨-1)˜ 𝕩} ⋄ K´ ⟨(qb-𝕨-D𝕩) E g.id, 𝕨 E g.id, 𝕩⟩ ⋄ •Show D𝕩 }
    L ← {E ← {0=𝕨 ? 1; K⍟(𝕨-1)˜ 𝕩} ⋄ K´ ⟨(qb-𝕨-D𝕩) E g.id, 𝕨 E g.id, 𝕩⟩ ⋄ •Show D𝕩 }
    T ← ∾↕∘≠{a←𝕩 ⋄ i←𝕨{𝕩⊑a}•_while_{𝕩<𝕨}𝕨⊑a ⋄ 𝕨<◶⟨⟩‿{(⊢∾1⊸↓∘⌽)𝕨+↕𝕩-𝕨}i}¨<
    A ← {v𝕊qs‿gs:
      1=◶{
        ui‿pt ← ⟨0 L gs, T qs (⌽∘⊢∾¬∘∊/⊣)˜ ↕qb⟩
        #v M˜ {0=≠𝕩 ? ui; {ui 𝕨⊸M∘M 𝕩}´ (M˜∘⌽⋈M)´ {𝕩 L g.swap}¨ 𝕩} pt
        •Show ≢∘⊑¨ v‿ui
      }‿(v M˜ gs L˜ ⊑qs) ≠qs}
    »⊸<∨` 0(-`˜⟜U˜<⊣) +○(×˜)˝ psi A˜´ ⌽sc
  }
  C +˝Q⍟(r⥊1) qb‿sc
#+end_src

#+RESULTS: interpreter
: 2
: ⟨ ⟨ 32 ⟩ ⟨⟩ ⟩
: 2
: Error: `: 𝕩 cannot have rank 0
: at   »⊸<∨` 0(-`˜⟜U˜<⊣) +○(×˜)˝ psi A˜´ ⌽sc
:             ^^^^^^^^^^
: at C +˝Q⍟(r⥊1) qb‿sc
:        ^^^^^^^


** Shor's algorithm

As a test case, we employ the quantum circuit of Shor's algorithm
for the number fifteen and base eleven, following references
[[https://arxiv.org/abs/1804.03719][arXiv:1804.03719]] and [[https://arxiv.org/abs/2306.09122][arXiv:2306.09122]]. The resulting compiled circuit
uses five qubits, three of which serve as control. To enhance
statistical accuracy, the experiment is repeated multiple times.
Additionally, we define a classical post-processing function:

#+name: test
#+begin_src bqn :exports code :tangle ./perf/q.bqn
  n‿a‿qb‿r ← ⟨15, 11, 5, 5⟩

  sc ← ⟨
    ⟨0⟩‿g.h #⋄ ⟨1⟩‿g.h ⋄ ⟨2⟩‿g.h
    #⟨2, 3⟩‿g.cnot ⋄ ⟨2, 4⟩‿g.cnot ⋄ ⟨1⟩‿g.h
    #⟨⟨1, 0⟩, g.P π÷2⟩ ⋄ ⟨0⟩‿g.h
    #⟨⟨1, 2⟩, g.P π÷4⟩ ⋄ ⟨⟨0, 2⟩, g.P π÷2⟩ ⋄ ⟨2⟩‿g.h
  ⟩

  #  C ← {n (⊣≡×´∘GCD) +‿-{𝕩𝕎1}¨ a⋆(≠÷2×⊑∘⍒) 0⌾⊑+˝∘‿(2⋆qb-2)⥊𝕩}
  C ← {n GCD +‿-{𝕩𝕎1}¨ a⋆(≠÷2×⊑∘⍒) 0⌾⊑+˝∘‿(2⋆qb-2)⥊𝕩}
#+end_src

#+RESULTS: test
: (function block)

Wir müssen wissen, wir werden wissen!

#+name: run
#+begin_src bqn :exports both :tangle ./perf/q.bqn
  C +˝Q⍟(r⥊1) qb‿sc
#+end_src

#+RESULTS: run
: Error: Mapping: Expected equal shape prefix (⟨512⟩ ≡ ≢𝕨, ⟨32⟩ ≡ ≢𝕩)
: at       v M˜ ui
:            ^^
: at     1=◶{
:           ^
: at   »⊸<∨` 0(-`˜⟜U˜<⊣) +○(×˜)˝ psi A˜´ ⌽sc
:                                    ^^^
: at C +˝Q⍟(r⥊1) qb‿sc
:        ^^^^^^^

Compare the result with that from a real [[./ibm_eagle/shor_factorize_fifteen.html][quantum computer]].

** Epilogue

Why BQN, you may ask? Its tacit and functional style together with its support
for numerous combinators, which makes programming feel like solving an algebraic problem
rather than drafting a political manifesto. Try running the simulation in
the call_generate-bqn-link() and explore it! While the interpreter is not
particularly optimized, here is a comparison with Common Lisp for those who are curious:

#+begin_export html
<details>
<summary>CBQN vs SBCL</summary>
#+end_export

#+begin_src bash :exports results :tangle no :results raw :wrap example
  #hyperfine --runs 5 'cbqn -f ./perf/q.bqn' 'sbcl --script ./perf/q.lisp'
  hyperfine --runs 5 'cbqn -f ./perf/q.bqn'
#+end_src

#+RESULTS:
#+begin_example
Benchmark 1: cbqn -f ./perf/q.bqn
  Time (mean ± σ):       2.5 ms ±   0.4 ms    [User: 1.5 ms, System: 1.3 ms]
  Range (min … max):     2.0 ms …   3.0 ms    5 runs
 
#+end_example

#+begin_export html
</details>
#+end_export

The full source code of this project is hosted in a GitHub [[https://github.com/Panadestein/bqun][repository]].

#+name: generate-bqn-link
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (let* ((bqn-code (concat "<<preamble>>\n\n" "<<interpreter>>\n\n" "<<test>>\n\n" "<<run>>"))
         (encoded (base64-encode-string (encode-coding-string bqn-code 'utf-8) t)))
    (concat "[[https://mlochbaum.github.io/BQN/try.html#code=" encoded "][BQN repl]]"))
#+end_src

#+name: count-chars
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (- (length "<<interpreter>>") 4)
#+end_src
