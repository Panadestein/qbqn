# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: A quantum interpreter in BQN
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>

** Preamble

We start by importing some required system functions, and defining some utilities to
work with complex numbers and a namespace with the required quantum gates:

#+name: preamble
#+begin_src bqn :exports code :results none
  Sinâ€¿Cosâ€¿GCD â† â€¢math
  U â† â€¢rand.Range
  _cp â† {(-Â´ğ”½Â¨)â‹ˆ(+Â´ğ”½Â¨)âŸœâŒ½}
    
  g â† {
    idâ€¿xâ‡âŒ½â€¿âŠ¢{ğ•ğ•©}Â¨ <=âŒœËœâ†•2, hâ‡-âŒ¾(1â€¿1âŠ¸âŠ‘)2â€¿2â¥ŠÃ·âˆš2
    swapâ€¿cnotâ‡âŸ¨1â€¿2, 2â€¿3âŸ© {âŒ½âŒ¾(ğ•¨âŠ¸âŠ)ğ•©}Â¨ <=âŒœËœâ†•4
    Pâ‡3â€¿3âŠ¸âŠ‘{(SinâŒ¾ğ”½â‹ˆCosâŒ¾ğ”½) ğ•©âŒ¾ğ”½ =âŒœËœâ†•4}
  }
#+end_src

** Interpreter

The (100 chars) quantum interpreter is based on references [[https://arxiv.org/abs/1711.02086][arXiv:1711.02086]] and
[[https://arxiv.org/abs/1608.03355][arXiv:1608.03355]]. For simplicity, we always measure at the end of the execution:

#+name: interpreter
#+begin_src bqn :exports code
  Q â† {ğ•Šqbâ€¿sc:
    psiâ€¿hs â† ({1âŒ¾âŠ‘ğ•©â¥Š0}â‹ˆâŠ¢) 2â‹†qb
    K â† {(âˆ¾âŠ£Ã—Â·<âŠ¢)âŸ(ğ•¨-1)Ëœ ğ•©}
    L â† {(âˆ¾âŠ£Ã—Â·<âŠ¢)Â´ âŸ¨(hs-ğ•¨-â‰ ğ•©) K g.id, ğ•©, ğ•¨ K g.id âŸ©}
    T â† â†•âˆ˜â‰ â‰â‹âˆ˜â‹
    Â»âŠ¸<âˆ¨` 0(-`ËœâŸœUËœ<âŠ£) psi
    T [2, 0, 3, 1]
  }
  Q qbâ€¿sc
  # [(0, 2), (1, 2), (2, 3)]
  (â†•âˆ˜â‰ â‰âŠ¢) (âŠ¢/Ëœâ†•âˆ˜â‰ <âŠ¢) (âŠ¢Â´âˆ§)Â¨1â†“â†‘ [2, 0, 3, 1, 4, 5, 7, 6]
  {(âŠ¢/Ëœâ†•âˆ˜â‰ <âŠ¢) (â†•âˆ˜â‰ â‹ˆâŠ¢) (âŠ¢Â´âˆ§)Â¨1â†“â†‘ğ•©} [2, 0, 3, 1, 4, 5, 7, 6]
#+end_src

#+RESULTS: interpreter
: âŸ¨ 2 2 3 7 âŸ©

** Shor's algorithm

As a test case, we employ the quantum circuit of Shor's algorithm
for the number fifteen and base eleven, following references
[[https://arxiv.org/abs/1804.03719][arXiv:1804.03719]] and [[https://arxiv.org/abs/2306.09122][arXiv:2306.09122]]. The resulting compiled circuit
uses five qubits, three of which serve as control qubits. To enhance
statistical accuracy, the experiment is repeated multiple times.
Additionally, we define a classical post-processing function:

#+name: test
#+begin_src bqn :exports code :results none
  nâ€¿aâ€¿qbâ€¿r â† âŸ¨15, 11, 5, 2â‹†10âŸ©

  sc â† âŸ¨
    âŸ¨0âŸ©â€¿g.h â‹„ âŸ¨1âŸ©â€¿g.h â‹„ âŸ¨2âŸ©â€¿g.h
    âŸ¨2, 3âŸ©â€¿g.cnot â‹„ âŸ¨2, 4âŸ©â€¿g.cnot â‹„ âŸ¨1âŸ©â€¿g.h
    âŸ¨âŸ¨1, 0âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨0âŸ©â€¿g.h
    âŸ¨âŸ¨1, 2âŸ©, g.P Ï€Ã·4âŸ© â‹„ âŸ¨âŸ¨0, 2âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨2âŸ©â€¿g.h
  âŸ©

  C â† {n (âŠ£â‰¡Ã—Â´âˆ˜GCD) +â€¿-{ğ•©ğ•1}Â¨ aâ‹†(â‰ Ã·2Ã—âŠ‘âˆ˜â’) 0âŒ¾âŠ‘+Ëâˆ˜â€¿(2â‹†qb-2)â¥Šğ•©}
#+end_src

Wir mÃ¼ssen wissen, wir werden wissen!

#+name: run
#+begin_src bqn
  C +ËQâŸ(râ¥Š1) qbâ€¿sc
#+end_src

The simulation can be run in the call_generate-bqn-link(), and the results can be
compared with those from a real [[./ibm_eagle/shor_factorize_fifteen.html][quantum computer]]. The complete source code is available in
a GitHub [[https://github.com/Panadestein/bqun][repository]]. 

#+name: generate-bqn-link
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw
  (let* ((bqn-code (concat "<<preamble>>\n\n" "<<interpreter>>\n\n" "<<test>>\n\n" "<<run>>"))
         (encoded (base64-encode-string (encode-coding-string bqn-code 'utf-8) t)))
    (concat "[[https://mlochbaum.github.io/BQN/try.html#code=" encoded "][BQN repl]]"))
#+end_src
