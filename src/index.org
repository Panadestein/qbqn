# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: A quantum interpreter in BQN
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>

** Preamble

We start by importing some required system functions, and defining some utilities to
work with complex numbers and a namespace with the required quantum gates:

#+name: preamble
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  Sinâ€¿Cosâ€¿GCD â† â€¢math
  U â† â€¢rand.Range
  _cp â† {(-Â´ğ”½Â¨)â‹ˆ(+Â´ğ”½Â¨)âŸœâŒ½}
    
  g â† {
    idâ€¿xâ‡âŒ½â€¿âŠ¢{ğ•ğ•©}Â¨ <=âŒœËœâ†•2, hâ‡-âŒ¾(1â€¿1âŠ¸âŠ‘)2â€¿2â¥ŠÃ·âˆš2
    swapâ€¿cnotâ‡âŸ¨1â€¿2, 2â€¿3âŸ© {âŒ½âŒ¾(ğ•¨âŠ¸âŠ)ğ•©}Â¨ <=âŒœËœâ†•4
    Pâ‡3â€¿3âŠ¸âŠ‘{(SinâŒ¾ğ”½â‹ˆCosâŒ¾ğ”½) ğ•©âŒ¾ğ”½ =âŒœËœâ†•4}
  }
#+end_src


** Interpreter

The (call_count-chars() chars) quantum interpreter is based on references [[https://arxiv.org/abs/1711.02086][arXiv:1711.02086]]
and [[https://arxiv.org/abs/1608.03355][arXiv:1608.03355]]. For simplicity, we always measure at the end of the execution:

#+name: interpreter
#+begin_src bqn :exports code :tangle ./perf/q.bqn
  Q â† {ğ•Šqbâ€¿sc:
    psiâ€¿hs â† ({1âŒ¾âŠ‘ğ•©â¥Š0}â‹ˆâŠ¢) 2â‹†qb
    MVâ€¿KM â† (+Ëâˆ˜Ã—â‰1â€¿âˆ)â€¿(âˆ¾âŠ£Ã—Â·<âŠ¢)
    K â† {KMâŸ(ğ•¨-1)Ëœ ğ•©}
    L â† {KMÂ´ âŸ¨(hs-ğ•¨-â‰ ğ•©) K g.id, ğ•©, ğ•¨ K g.id âŸ©}
    T â† âˆ¾â†•âˆ˜â‰ {aâ†ğ•© â‹„ iâ†ğ•¨{ğ•©âŠ‘a}â€¢_while_{ğ•©<ğ•¨}ğ•¨âŠ‘a â‹„ ğ•¨<â—¶âŸ¨âŸ©â€¿{(âŠ¢âˆ¾1âŠ¸â†“âˆ˜âŒ½)ğ•¨+â†•ğ•©-ğ•¨}i}Â¨<
    A â† 1âŠ¸=â—¶{Lğ•¨ MV _cp ğ•©}â€¿@âˆ˜â‰  âŠ
    Â»âŠ¸<âˆ¨` 0(-`ËœâŸœUËœ<âŠ£) psi AËœÂ´ âŒ½sc
  }
#+end_src

#+RESULTS: interpreter
: (function block)

** Shor's algorithm

As a test case, we employ the quantum circuit of Shor's algorithm
for the number fifteen and base eleven, following references
[[https://arxiv.org/abs/1804.03719][arXiv:1804.03719]] and [[https://arxiv.org/abs/2306.09122][arXiv:2306.09122]]. The resulting compiled circuit
uses five qubits, three of which serve as control qubits. To enhance
statistical accuracy, the experiment is repeated multiple times.
Additionally, we define a classical post-processing function:

#+name: test
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  nâ€¿aâ€¿qbâ€¿r â† âŸ¨15, 11, 5, 2â‹†10âŸ©

  sc â† âŸ¨
    âŸ¨0âŸ©â€¿g.h â‹„ âŸ¨1âŸ©â€¿g.h â‹„ âŸ¨2âŸ©â€¿g.h
    âŸ¨2, 3âŸ©â€¿g.cnot â‹„ âŸ¨2, 4âŸ©â€¿g.cnot â‹„ âŸ¨1âŸ©â€¿g.h
    âŸ¨âŸ¨1, 0âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨0âŸ©â€¿g.h
    âŸ¨âŸ¨1, 2âŸ©, g.P Ï€Ã·4âŸ© â‹„ âŸ¨âŸ¨0, 2âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨2âŸ©â€¿g.h
  âŸ©

  C â† {n (âŠ£â‰¡Ã—Â´âˆ˜GCD) +â€¿-{ğ•©ğ•1}Â¨ aâ‹†(â‰ Ã·2Ã—âŠ‘âˆ˜â’) 0âŒ¾âŠ‘+Ëâˆ˜â€¿(2â‹†qb-2)â¥Šğ•©}
#+end_src

Wir mÃ¼ssen wissen, wir werden wissen!

#+name: run
#+begin_src bqn :exports both :tangle ./perf/q.bqn
  C +ËQâŸ(râ¥Š1) qbâ€¿sc
#+end_src

Compare the result with that from a real [[./ibm_eagle/shor_factorize_fifteen.html][quantum computer]].

** Epilogue

Why BQN, you may ask? Well, its tacit and functional style together with the support for
many combinators makes programming feel like solving a fun algebraic problem,
as opposed to writing a manifesto. Try to run the simulation in
the call_generate-bqn-link() and explore it! The interpreter is not particularly optimized,
but here it is a comparison with Common Lisp in case you are curious:

#+begin_export html
<details>
<summary>CBQN vs SBCL</summary>
#+end_export

#+begin_src bash :exports results :tangle no :results raw :wrap example
  #hyperfine --runs 5 'cbqn -f ./perf/q.bqn' 'sbcl --script ./perf/q.lisp'
  hyperfine --runs 5 'cbqn -f ./perf/q.bqn'
#+end_src

#+RESULTS:
#+begin_example
Benchmark 1: cbqn -f ./perf/q.bqn
  Time (mean Â± Ïƒ):       2.5 ms Â±   0.4 ms    [User: 1.5 ms, System: 1.3 ms]
  Range (min â€¦ max):     2.0 ms â€¦   3.0 ms    5 runs
 
#+end_example

#+begin_export html
</details>
#+end_export

The full source code of this project is hosted in a GitHub [[https://github.com/Panadestein/bqun][repository]].

#+name: generate-bqn-link
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (let* ((bqn-code (concat "<<preamble>>\n\n" "<<interpreter>>\n\n" "<<test>>\n\n" "<<run>>"))
         (encoded (base64-encode-string (encode-coding-string bqn-code 'utf-8) t)))
    (concat "[[https://mlochbaum.github.io/BQN/try.html#code=" encoded "][BQN repl]]"))
#+end_src

#+name: count-chars
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (- (length "<<interpreter>>") 4)
#+end_src
