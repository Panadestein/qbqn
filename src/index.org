# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: BQN's Quantum Noise
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>

** Preamble

We will implement and test a compact quantum interpreter in the BQN programming language.
Initially, we import the necessary system functions and define a 1-modifier for handling
complex matrix products. Next, we define a namespace containing various quantum gates:

#+name: preamble
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  Sinâ€¿Cosâ€¿GCD â† â€¢math
  U â† â€¢rand.Range
  _cp â† {(-Â´ğ”½Â¨)â‹ˆ(+Â´ğ”½Â¨)âŸœâŒ½}
    
  g â† {
    IM â† (âŠ¢â‹ˆâ‰¢â¥ŠâŸœ0âŠ¢)Â¨
    xâ€¿idâ€¿h â‡ (âŒ½â€¿âŠ¢{ğ•ğ•©}Â¨<=âŒœËœâ†•2) âˆ¾â—‹IM <-âŒ¾(1â€¿1âŠ¸âŠ‘)2â€¿2â¥ŠÃ·âˆš2
    swapâ€¿cnot â‡ IM âŸ¨1â€¿2, 2â€¿3âŸ© {âŒ½âŒ¾(ğ•¨âŠ¸âŠ)ğ•©}Â¨ <=âŒœËœâ†•4
    P â‡ 3â€¿3âŠ¸âŠ‘{smâ€¿cm â† ğ•©âŒ¾ğ”½Â¨ âŸ¨=âŒœËœâ†•4,  4â€¿4â¥Š0âŸ© â‹„ âŸ¨SinâŒ¾ğ”½ sm, CosâŒ¾ğ”½ cmâŸ©}
  }
#+end_src

** Interpreter

The (call_count-chars() chars) quantum interpreter is based on references [[https://arxiv.org/abs/1711.02086][arXiv:1711.02086]]
and [[https://arxiv.org/abs/1608.03355][arXiv:1608.03355]]. For simplicity, we always measure at the end of the execution:

#+name: interpreter
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  Q â† {ğ•Šqbâ€¿scâ€¿rnd:
    psi â† {(1âŒ¾âŠ‘â‹ˆâŠ¢)ğ•©â¥Š0} 2â‹†qb
    Mâ€¿Kâ€¿D â† âŸ¨+Ëâˆ˜Ã—â‰1â€¿âˆ _cp, {1â‰¡ğ•© ? ğ•¨; 1â‰¡ğ•¨ ? ğ•©; ğ•¨(âˆ¾âŠ£Ã—Â·<âŠ¢)_cpğ•©}, {âŒŠ2â‹†â¼â‰ âŠ‘ğ•©}âŸ©
    L â† {E â† {0=ğ•¨ ? 1; KâŸ(ğ•¨-1)Ëœ ğ•©} â‹„ KÂ´ âŸ¨(qb-ğ•¨+Dğ•©) E g.id, ğ•©, ğ•¨ E g.idâŸ©}
    T â† âˆ¾â†•âˆ˜â‰ {aâ†ğ•© â‹„ iâ†ğ•¨{ğ•©âŠ‘a}â€¢_while_{ğ•©<ğ•¨}ğ•¨âŠ‘a â‹„ ğ•¨<â—¶âŸ¨âŸ©â€¿{(âŠ¢âˆ¾1âŠ¸â†“âˆ˜âŒ½)ğ•¨+â†•ğ•©-ğ•¨}i}Â¨<
    A â† {qsâ€¿gsğ•Šv:
      1âŠ¸=â—¶{ğ•Šğ•©:
        uiâ€¿pt â† âŸ¨0 L gs, T qs (âŒ½âˆ˜âŠ¢âˆ¾Â¬âˆ˜âˆŠ/âŠ£)Ëœ â†•qbâŸ©
        v MËœ {0=â‰ ğ•© ? ui; {ğ•© M (ui M ğ•¨)}Â´ (MËœÂ´â‹ˆMÂ´) {ğ•© L g.swap}Â¨ ğ•©} pt
      }â€¿(v MËœ gs LËœ âŠ‘qs) â‰ qs}
    Â»âŠ¸<âˆ¨` 0> rnd -` >+â—‹(Ã—Ëœ)Ë psi AÂ´ âŒ½sc
  }
#+end_src

** Shor's algorithm

As a test case, we employ the quantum circuit of Shor's algorithm
for the number fifteen and base eleven, following references
[[https://arxiv.org/abs/1804.03719][arXiv:1804.03719]] and [[https://arxiv.org/abs/2306.09122][arXiv:2306.09122]]. The resulting compiled circuit
uses five qubits, three of which serve as control. To enhance
statistical accuracy, the experiment is repeated multiple times.
Additionally, we define a classical post-processing function:

#+name: test
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  nâ€¿aâ€¿qbâ€¿r â† âŸ¨15, 11, 5, 0 UËœ 2â‹†3âŸ©

  sc â† âŸ¨
    âŸ¨0âŸ©â€¿g.h â‹„ âŸ¨1âŸ©â€¿g.h â‹„ âŸ¨2âŸ©â€¿g.h
    âŸ¨2, 3âŸ©â€¿g.cnot â‹„ âŸ¨2, 4âŸ©â€¿g.cnot â‹„ âŸ¨1âŸ©â€¿g.h
    âŸ¨âŸ¨1, 0âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨0âŸ©â€¿g.h
    âŸ¨âŸ¨1, 2âŸ©, g.P Ï€Ã·4âŸ© â‹„ âŸ¨âŸ¨0, 2âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨2âŸ©â€¿g.h
  âŸ©

  C â† {n (âŠ£â‰¡Ã—Â´âˆ˜GCD) +â€¿-{ğ•©ğ•1}Â¨ <aâ‹†(â‰ Ã·2Ã—âŠ‘âˆ˜â’) 0âŒ¾âŠ‘+Ëâˆ˜â€¿(2â‹†qb-2)â¥Šğ•©}
#+end_src

Wir mÃ¼ssen wissen, wir werden wissen!

#+name: run
#+begin_src bqn :exports both :tangle ./perf/q.bqn
  C >+Ë{Q qbâ€¿scâ€¿ğ•©}Â¨ r
#+end_src

#+RESULTS: run
: 1

Compare the result with that from a real [[./ibm_eagle/shor_factorize_fifteen.html][quantum computer]].

** Epilogue

Why BQN, you may ask? Its tacit and functional style together with its support
for numerous combinators, which makes programming feel like solving a fun algebraic problem
rather than drafting a manifesto. Try running the simulation in
the call_generate-bqn-link() and explore it! While the interpreter is not
particularly optimized, here is a comparison with Common Lisp for those who are curious:

#+begin_export html
<details>
<summary>CBQN vs SBCL</summary>
#+end_export

#+begin_src bash :exports results :tangle no :results raw :wrap example
  hyperfine --runs 5 'cbqn -f ./perf/q.bqn' 'sbcl --script ./perf/q.lisp'
#+end_src

#+RESULTS:
#+begin_example
Benchmark 1: cbqn -f ./perf/q.bqn
  Time (mean Â± Ïƒ):      65.3 ms Â±  42.2 ms    [User: 63.7 ms, System: 1.4 ms]
  Range (min â€¦ max):    43.8 ms â€¦ 140.6 ms    5 runs
 
Benchmark 2: sbcl --script ./perf/q.lisp
  Time (mean Â± Ïƒ):      9.231 s Â±  0.096 s    [User: 9.289 s, System: 0.091 s]
  Range (min â€¦ max):    9.076 s â€¦  9.339 s    5 runs
 
Summary
  cbqn -f ./perf/q.bqn ran
  141.25 Â± 91.26 times faster than sbcl --script ./perf/q.lisp
#+end_example

#+begin_export html
</details>
#+end_export

The title of this post doesn't have a particular meaning, it's only a recursive acronym that appears to be on-topic.
The full source code is hosted in a GitHub [[https://github.com/Panadestein/qbqn][repository]].

#+name: generate-bqn-link
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (let* ((bqn-code (concat "<<preamble>>\n\n" "<<interpreter>>\n\n" "<<test>>\n\n" "<<run>>"))
         (encoded (base64-encode-string (encode-coding-string bqn-code 'utf-8) t)))
    (concat "[[https://mlochbaum.github.io/BQN/try.html#code=" encoded "][BQN repl]]"))
#+end_src

#+name: count-chars
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (- (length "<<interpreter>>") 4)
#+end_src
