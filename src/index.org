# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: BQN's Quantum Noise
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>

** Preamble

We will implement and test a compact quantum interpreter in the BQN[fn:1] programming language.
Initially, we import the necessary system functions and define a 1-modifier for handling
complex matrix products. Next, we define a namespace containing various quantum gates:

#+name: preamble
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  Sinâ€¿Cosâ€¿GCD â† â€¢math
  U â† â€¢rand.Range
  _cp â† {(-Â´ğ”½Â¨)â‹ˆ(+Â´ğ”½Â¨)âŸœâŒ½}
    
  g â† {
    IM â† (âŠ¢â‹ˆâ‰¢â¥ŠâŸœ0âŠ¢)Â¨
    xâ€¿idâ€¿h â‡ (âŒ½â€¿âŠ¢{ğ•ğ•©}Â¨<=âŒœËœâ†•2) âˆ¾â—‹IM <-âŒ¾(1â€¿1âŠ¸âŠ‘)2â€¿2â¥ŠÃ·âˆš2
    swapâ€¿cnot â‡ IM âŸ¨1â€¿2, 2â€¿3âŸ© {âŒ½âŒ¾(ğ•¨âŠ¸âŠ)ğ•©}Â¨ <=âŒœËœâ†•4
    P â‡ {âŸ¨=âŒœËœâ†•4,  4â€¿4â¥Š0âŸ© {ğ•¨âŒ¾(3â€¿3âŠ¸âŠ‘) ğ•©}Â¨Ëœ SinâŠ¸â‹ˆâŸœCos ğ•©}
  }
#+end_src

** Interpreter

The (call_count-chars() chars[fn:2]) quantum interpreter is based on references [[https://arxiv.org/abs/1711.02086][arXiv:1711.02086]]
and [[https://arxiv.org/abs/1608.03355][arXiv:1608.03355]]. For simplicity, we always measure at the end of the execution:

#+name: interpreter
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  Q â† {ğ•Šqbâ€¿scâ€¿rnd:
    psi â† {(1âŒ¾âŠ‘â‹ˆâŠ¢)ğ•©â¥Š0} 2â‹†qb
    Mâ€¿K â† âŸ¨+Ëâˆ˜Ã—â‰1â€¿âˆ _cp, {1â‰¡ğ•© ? ğ•¨; 1â‰¡ğ•¨ ? ğ•©; ğ•¨(âˆ¾âŠ£Ã—Â·<âŠ¢)_cpğ•©}âŸ©
    Dâ€¿E â† {âŒŠ2â‹†â¼â‰ âŠ‘ğ•©}â€¿{0=ğ•¨ ? 1; KâŸ(ğ•¨-1)Ëœ ğ•©}
    L â† {KÂ´ âŸ¨(qb-ğ•¨+Dğ•©) E g.id, ğ•©, ğ•¨ E g.idâŸ©}
    T â† âˆ¾â†•âˆ˜â‰ {aâ†ğ•© â‹„ iâ†ğ•¨{ğ•©âŠ‘a}â€¢_while_{ğ•©<ğ•¨}ğ•¨âŠ‘a â‹„ ğ•¨<â—¶âŸ¨âŸ©â€¿{(âŠ¢âˆ¾1âŠ¸â†“âˆ˜âŒ½)ğ•¨+â†•ğ•©-ğ•¨}i}Â¨<
    A â† {qsâ€¿gsğ•Šv:
      1âŠ¸=â—¶{ğ•Šğ•©:
        uiâ€¿pt â† âŸ¨0 L gs, T qs (âŒ½âˆ˜âŠ¢âˆ¾Â¬âˆ˜âˆŠ/âŠ£)Ëœ â†•qbâŸ©
        v MËœ {0=â‰ ğ•© ? ui; {ğ•© M ui M ğ•¨}Â´ (MËœÂ´â‹ˆMÂ´) {ğ•© L g.swap}Â¨ ğ•©} pt
      }â€¿(v MËœ gs LËœ âŠ‘qs) â‰ qs}
    Â»âŠ¸<âˆ¨` 0> rnd -` >+â—‹(Ã—Ëœ)Ë psi AÂ´ âŒ½sc
  }
#+end_src

** Shor's algorithm

As a test case, we employ the quantum circuit of Shor's algorithm
for the number fifteen and base eleven, following references
[[https://arxiv.org/abs/1804.03719][arXiv:1804.03719]] and [[https://arxiv.org/abs/2306.09122][arXiv:2306.09122]]. The resulting compiled circuit
uses five qubits, three of which serve as control. To enhance
statistical accuracy, the experiment is repeated multiple times.
Additionally, we define a classical post-processing function:

#+name: test
#+begin_src bqn :exports code :results none :tangle ./perf/q.bqn
  nâ€¿aâ€¿qbâ€¿r â† âŸ¨15, 11, 5, 0 UËœ 2â‹†3âŸ©

  sc â† âŸ¨
    âŸ¨0âŸ©â€¿g.h â‹„ âŸ¨1âŸ©â€¿g.h â‹„ âŸ¨2âŸ©â€¿g.h
    âŸ¨2, 3âŸ©â€¿g.cnot â‹„ âŸ¨2, 4âŸ©â€¿g.cnot â‹„ âŸ¨1âŸ©â€¿g.h
    âŸ¨âŸ¨1, 0âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨0âŸ©â€¿g.h
    âŸ¨âŸ¨1, 2âŸ©, g.P Ï€Ã·4âŸ© â‹„ âŸ¨âŸ¨0, 2âŸ©, g.P Ï€Ã·2âŸ© â‹„ âŸ¨2âŸ©â€¿g.h
  âŸ©

  C â† {n (âŠ£â‰¡Ã—Â´âˆ˜GCD) +â€¿-{ğ•©ğ•1}Â¨ <aâ‹†(â‰ Ã·2Ã—âŠ‘âˆ˜â’) 0âŒ¾âŠ‘+Ëâˆ˜â€¿(2â‹†qb-2)â¥Šğ•©}
#+end_src

Wir mÃ¼ssen wissen, wir werden wissen![fn:3]

#+name: run
#+begin_src bqn :exports both :tangle ./perf/q.bqn
  C >+Ë{Q qbâ€¿scâ€¿ğ•©}Â¨ r
#+end_src

#+RESULTS: run
: 1

Compare the result with that from a real [[./ibm_eagle/shor_factorize_fifteen.html][quantum computer]].

** Epilogue

Why the hieroglyphs, you may ask? Tacit plus functional style together with numerous combinators
makes programming feel like solving a fun algebraic problem rather than drafting a manifesto.
BQN is the epitome of minimalism's power:

#+begin_export html
<details>
<summary>Primitive's stats</summary>
#+end_export

The src_bqn[:exports code]{prog} string contains the full source code. We used:

#+begin_src bqn :noweb yes :noweb-prefix no :exports none :tangle no :results none
  prog â† "<<preamble>><<interpreter>><<test>><<run>>"
#+end_src

#+begin_src bqn :noweb yes :noweb-prefix no :exports both :tangle no :wrap example
  prog (+Â´âŠ¸â‰âŸœâ‰ âˆŠ)Ëœ âŠ‘Â¨â€¢primitives
#+end_src

#+RESULTS:
#+begin_example
âŸ¨ 44 64 âŸ©
#+end_example

With this distribution:

#+begin_src bqn :noweb yes :noweb-prefix no :exports both :tangle no :wrap example
  â‰>(â·âˆ¾â‰ )Â¨âˆ˜(âŠâŠ¸âŠ”âˆŠ/âŠ£)âŸœ(âŠ‘Â¨â€¢primitives)Ëœ prog
#+end_src

#+RESULTS:
#+begin_example
â”Œâ”€                                                                                                                                                                                 
â•µ '-' 'Â´' 'Â¨' 'â‹ˆ' '+' 'âŸœ' 'âŒ½' 'âŠ¢' 'â‰¢' 'â¥Š' '<' '=' 'âŒœ' 'Ëœ' 'â†•' 'âˆ¾' 'â—‹' 'âŒ¾' 'âŠ¸' 'âŠ‘' 'Ã·' 'âˆš' 'âŠ' 'â‹†' 'Ë' 'âˆ˜' 'Ã—' 'â‰' 'â‰¡' 'âŠ£' 'âŒŠ' 'â¼' 'â‰ ' 'âŸ' 'â—¶' 'â†“' 'Â¬' 'âˆŠ' '/' 'Â»' 'âˆ¨' '`' '>' 'â’'  
  8   8   10  5   8   3   6   7   1   5   9   6   3   12  6   5   2   5   7   9   5   1   1   5   4   8   5   1   3   3   1   1   5   1   2   1   1   1   1   1   1   2   3   1    
                                                                                                                                                                                  â”˜
#+end_example

#+begin_export html
</details>
#+end_export

BQN is also fast:


#+begin_export html
<details>
<summary>Benchmarks</summary>
#+end_export

While the interpreter's performance is not particularly optimized, here is a comparison with the equivalent Common Lisp code:

#+begin_src bash :exports results :tangle no :results raw :wrap example
  hyperfine --runs 5 'cbqn -f ./perf/q.bqn' 'sbcl --script ./perf/q.lisp'
#+end_src

#+RESULTS:
#+begin_example
Benchmark 1: cbqn -f ./perf/q.bqn
  Time (mean Â± Ïƒ):      5.468 s Â±  0.077 s    [User: 5.427 s, System: 0.005 s]
  Range (min â€¦ max):    5.358 s â€¦  5.535 s    5 runs
 
Benchmark 2: sbcl --script ./perf/q.lisp
  Time (mean Â± Ïƒ):     37.114 s Â±  0.893 s    [User: 37.544 s, System: 0.207 s]
  Range (min â€¦ max):   36.457 s â€¦ 38.634 s    5 runs
 
Summary
  cbqn -f ./perf/q.bqn ran
    6.79 Â± 0.19 times faster than sbcl --script ./perf/q.lisp
#+end_example

And here is a full program's profile. All time is spent in the Kronecker and matrix products:

#+begin_src bqn :exports both :tangle no :results raw :wrap example
  )profile C >+Ë{Q qbâ€¿scâ€¿ğ•©}Â¨ r
#+end_src

#+RESULTS:
#+begin_example
Got 27984 samples
(REPL): 27984 samples:
     8â”‚  Q â† {ğ•Šqbâ€¿scâ€¿rnd:
     1â”‚    psi â† {(1âŒ¾âŠ‘â‹ˆâŠ¢)ğ•©â¥Š0} 2â‹†qb
  2522â”‚    Mâ€¿K â† âŸ¨+Ëâˆ˜Ã—â‰1â€¿âˆ _cp, {1â‰¡ğ•© ? ğ•¨; 1â‰¡ğ•¨ ? ğ•©; ğ•¨(âˆ¾âŠ£Ã—Â·<âŠ¢)_cpğ•©}âŸ©
    29â”‚    Dâ€¿E â† {âŒŠ2â‹†â¼â‰ âŠ‘ğ•©}â€¿{0=ğ•¨ ? 1; KâŸ(ğ•¨-1)Ëœ ğ•©}
    28â”‚    L â† {KÂ´ âŸ¨(qb-ğ•¨+Dğ•©) E g.id, ğ•©, ğ•¨ E g.idâŸ©}
    14â”‚    T â† âˆ¾â†•âˆ˜â‰ {aâ†ğ•© â‹„ iâ†ğ•¨{ğ•©âŠ‘a}â€¢_while_{ğ•©<ğ•¨}ğ•¨âŠ‘a â‹„ ğ•¨<â—¶âŸ¨âŸ©â€¿{(âŠ¢âˆ¾1âŠ¸â†“âˆ˜âŒ½)ğ•¨+â†•ğ•©-ğ•¨}i}Â¨<
     3â”‚    A â† {qsâ€¿gsğ•Šv:
     2â”‚      1âŠ¸=â—¶{ğ•Šğ•©:
    16â”‚        uiâ€¿pt â† âŸ¨0 L gs, T qs (âŒ½âˆ˜âŠ¢âˆ¾Â¬âˆ˜âˆŠ/âŠ£)Ëœ â†•qbâŸ©
 24976â”‚        v MËœ {0=â‰ ğ•© ? ui; {ğ•© M ui M ğ•¨}Â´ (MËœÂ´â‹ˆMÂ´) {ğ•© L g.swap}Â¨ ğ•©} pt
   373â”‚      }â€¿(v MËœ gs LËœ âŠ‘qs) â‰ qs}
    12â”‚    Â»âŠ¸<âˆ¨` 0> rnd -` >+â—‹(Ã—Ëœ)Ë psi AÂ´ âŒ½sc
      â”‚  }
#+end_example

#+begin_export html
</details>
#+end_export

Try running the simulation in the call_generate-bqn-link() and explore it! The complete source code is hosted in a GitHub [[https://github.com/Panadestein/qbqn][repository]].
Additionally, I recommend reading Stylewarning's [[https://www.stylewarning.com/posts/quantum-interpreter/][blog post]],
which served as an inspiration for this one and kindly lists it as a re-implementation.

#+name: generate-bqn-link
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (let* ((bqn-code (concat "<<preamble>>\n\n" "<<interpreter>>\n\n" "<<test>>\n\n" "<<run>>"))
         (encoded (base64-encode-string (encode-coding-string bqn-code 'utf-8) t)))
    (concat "[[https://mlochbaum.github.io/BQN/try.html#code=" encoded "][BQN repl]]"))
#+end_src

#+name: count-chars
#+begin_src emacs-lisp :noweb yes :noweb-prefix no :exports none :results raw :tangle no
  (- (length "<<interpreter>>") 4)
#+end_src

[fn:1] This post's title is a playful recursive acronym that employs quantum computing terminology, without any specific significance beyond that.
[fn:2] Optimized, though not minimizing Kolmogorov complexity.
[fn:3] Hilbert's [[https://maa.org/press/periodicals/convergence/david-hilberts-radio-address-english-translation][radio address]] in 1930.
